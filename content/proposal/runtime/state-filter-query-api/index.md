---
type: blog
date: 2020-03-30
title: "状态存储过滤和查询API"
linkTitle: "状态存储过滤和查询API"
description: >
  状态存储过滤和查询API
---

状态存储过滤和查询API

## Proposal信息

[[Proposal] API for state store filtering and querying [like OData] #1339](https://github.com/dapr/dapr/issues/1339)

### 提案内容

我们想通过SDK（对我们来说是.NET SDK）中的Dapr.Client 将状态存储作为主存储使用，但是状态存储API只允许对一个存储的文档进行单一的GET请求。

如果能像 Cosmos DB 中描述的 OData 一样，有机会通过查询来检索更多的值，那将是非常好的。

DAPR API 调用的例子:

`GET http://localhost:3500/v1.0/state/people-storage?$filter=PartitionKey%20eq%20'Smith'%20and%20Email%20eq%20'Ben@contoso.com'`

如果能通过某种条件只检索到key，那就太好了。

DAPR API 调用的例子:

`GET http://localhost:3500/v1.0/state/people-storage?getAll=keys`

对于日常基本使用，状态管理缺少了作为主存储的查询使用。对于我们的使用，我们需要在我们的项目中使用自定义SDK，即使我们使用的是Dapr runtime，因为它可以进行更复杂的过滤调用，以获得多个记录，并通过一些条件进行过滤。

在目前的情况下，只能并行调用更多的GetAsync来获取所有的值。

### 提案的设计讨论

我相信额外的查询功能会给状态API增加很多价值，我已经提出了一个使用OData的潜在实现。

目标：启用客户端向Dapr状态API提交查询表达式。

非目标：

- 打破当前隔离状态边界，即每dapr应用隔离。
- 将所有数据库功能暴露给客户端应用。
- 过于复杂的状态API。

#### why

Dapr当前的状态API只方便通过给定的键从状态存储中检索一个条目。基于key来存储和检索value，本质上是key/value数据库的目的。这使得它们对于某种类型的隔离和高度并行的数据访问模式非常有用，例如购物车、会话状态或缓存。由于存储由key索引的数据的能力是大多数存储提供商的根本，因此在技术上可以将许多不同的存储技术 "当作" key-value存储而使用，尽管有些技术是为这种类型的数据存储进行了高度调整。

大多数客户的问题（不是全部）会需要比纯键值存储更高级的状态功能（没有分组、过滤等）。因此，目前Dapr状态API，不会适用于大多数状态管理问题。仅仅是这一点，并不足以成为为Dapr的状态API添加更复杂行为的理由。然而，如果大多数用户必须使用现有数据库提供商的SDK（mysql、mongo等），那么大多数用户也可以使用该SDK来满足他们的键值存储需求。我想说，很多用户需要同时使用数据库SDK和Dapr状态API的可能性相当小（虽然这只是猜测）。因此，你可以说，Dapr状态API只可能适用于专门需要简单键值存储的问题。在一些用户反馈中也提出了这一点。

我还想说的是，从Dapr的API中限制复杂性，只是把它移到用户的架构上。我见过很多奇特的架构用来绕过这种约束。比如发送'n'个并行请求来获取所有的数据，然后在本地进行过滤，在没有事务完整性的情况下同时存储单个记录和汇总值，甚至让很多服务维护二级索引。我们希望Dapr能够鼓励简单的架构设计，而不是强迫用户 "发挥创意"，绕过限制条件。

Dapr目前支持许多不同的状态提供者，这些状态提供者主要不是键值存储（参见下面的状态提供者）。此外，严格来说，是少数状态提供者不提供更高级的功能。因此，掩盖这些功能被客户端利用的是Dapr API的一个约束，而不是底层存储提供者缺乏支持。

值得一提的是，不同的数据技术有不同的数据模型，因此具有不同的功能。例如，键值存储通常只提供主键（或分区键+排序键的复合）的过滤功能，而文档存储可以跨整个文档查询，关系存储可以跨表查询。

还需要注意的是，在不同的存储技术上执行这些操作的性能会有很大的差异。例如，在键值存储上执行扫描通常是O(N)，除非使用二级索引。

#### Why OData?

Dapr暴露了HTTP REST API和gRPC API。本提案在这些限制条件下工作，因此，额外的API，如GraphQL已经被排除在外。

OData是一个标准规范，用于定义查询作为REST API的HTTP请求URI的一部分。OData的优点和缺点都有详细的记录，我相信每个人都有自己的看法。然而，另一种选择是编写一个自定义的查询规范和实现，这似乎是一个愚蠢的任务。

定义一个在HTTP API和gRPC API中都有意义的查询规范，需要太多的抽象层次。因此，我认为OData规范可以提供一个足够的查询语法，我们可以在两个API中使用。虽然我们可以考虑为gRPC提供一个类型安全的表示方法。

#### How?

这个变化意味着你可以在HTTP或gRPC请求中添加一个OData查询。对于HTTP来说，这将导致以下URI。

`http://localhost:<daprPor>/v1.0/state/<storename>?<odata-querystring>`

对于gRPC来说，我们需要在请求包中添加一个属性，在这个属性中可以存储查询。

下面的流程描述了dapr和状态提供者如何处理这个查询。

HTTP：

- 客户端发送一个HTTP请求，并将OData查询URL编码为querystring。
- HTTP GetState API从HTTP请求的querystring中提取OData查询。
- HTTP GetState API将OData查询解析成OData查询的抽象语法树（AST）表示。
- 如果HTTP GetState API未能解析OData查询，它将返回一个错误。
- HTTP GetState API将AST传递给状态存储提供者。
- 如果状态提供者不支持查询，它可以忽略AST或错误。
- 如果状态提供者确实支持查询，它必须实现一个查询构建器，它可以将OData AST转换为专门针对该提供者的查询，即SQL。
- 如果查询构建器不能将OData AST翻译成本地查询，它就会返回一个错误。
- 然后，状态提供者针对数据库执行本机查询，并返回结果。

gRPC: 

- gRPC客户端在GetStateRequest上将一个字符串属性设置为OData查询。
- gRPC GetState API从gRPC GetStateRequest对象中提取OData查询。
- 步骤3-9与HTTP流程相同。

这意味着每个状态提供者对查询的支持会有所不同，并会给API带来不一致的地方。现在切换状态提供者可能会导致错误。然而，目前的状态API已经不一致了，即一些提供者支持事务，而其他提供者不支持。我相信我们可以用类似于新的双向绑定API的方法来处理具有不同能力的提供者。这将使状态API不再是一个最低的共同点。你甚至有风味的状态提供者，即TSQL可以是支持多个存储提供者。

#### 构建OData解析和查询

下面的OData查询：

filter=CountryCode eq 'US' and FirstName eq 'Alice'.

将导致以下AST：

![](https://user-images.githubusercontent.com/7241190/79361622-74f27200-7f3d-11ea-9f6c-ca552ba5f9fc.png)

状态提供者必须实现一个查询构建器来遍历这棵树，并以他们的原生语法建立一个查询，即

SELECT * WHERE CountryCode='US' AND FirstName='Alice'

然而，如果这个特殊的AST被提供给一个不支持SQL的键值提供商（如Consul），那么它将是无效的，并不得不出错。

这就提出了几个重要的问题：

- Dapr是否应该区分键值状态提供者和其他类型（如文档和关系型）？
- 将Dapr限制为只对键值进行过滤（即使是文档和关系型存储）是否会给用户带来足够的体验？
- 我们是否应该有数据库特定的绑定，而让状态API保持原样？
- 我们是否应该有通用的存储绑定，而让State API保持原样？

#### 建议

这个话题需要对Dapr的状态管理目标进行更广泛的讨论，我才会乐意进一步支持这个想法。有很多功能（watch、UDF等）是由不同的存储厂商以不同的方式提供的，我们需要非常谨慎地考虑Dapr将其抽象化对最终用户的好处是什么。我还认为我们应该讨论一些我们可能要支持的架构模式，比如事件源、cqrs和saga，了解他们的需求。

我认为我们应该应用80:20规则，尝试确定能够满足大多数用户的最小查询集。这些查询应该由客户端使用OData表达，并在请求中传递，然后将其编译成AST（或其他内部查询表示）并传递给状态提供者处理。我们需要考虑如何正确处理不同提供者之间的不同查询支持，这样用户在更换组件时就不会被绊倒。

### 状态供应商

下面是每一个状态供应商的列表，还有对查询支持的说明。我们大致将它们分为3类，key-value、document、relational。这种区分是基于它们所暴露的语义，而不是它们实际存储数据的方式，例如，有些可能是面向列的。

详见原文。

### 实现的三个方式讨论

谢谢 @yaron2 给我指出这个建议。几周前，我写了另一个和这个非常相似的提案，但是使用了绑定和基于mongo的查询语言，这里是这个提案，https://github.com/dapr/components-contrib/issues/441 

在阅读了@jjcollinge所做的超棒的详细解释后，我认为我们可以将这两个提案融合在一起来解决状态存储的查询问题。

我认为有三种不同的方案可以探索：

1. 用绑定来实现，而用OData作为查询语言。在这种情况下，在Invoke方法里面，我们可以对OData字符串进行解析，只需将其转换为各个特定的数据库查询语言即可。在这种方法中，我们可以避免得到AST查询的中间解析。这种解决方案只是为当前每个数据库引擎的绑定实现简单复制而已

2. 使用绑定并开发一个解析器，从OData字符串中得到AST，AST传递给方法，将AST转化为特定的DB查询语言并执行。在这种情况下，我们可以开发一个特定的包，植入当前的绑定接口，并将Odata解析为AST，只是将AST的解析留给特定的引擎，交给每个数据库绑定组件。

3. 基于绑定创建一个新的数据库组件。以2中提出的非常类似的方式，实现从OData字符串到AST的解析，并按照@jjcollinge的建议将AST传递给每个特定的数据库包，在那里解析AST并执行查询。

在方案1和方案2中，Dapr的核心不需要修改，因为所有的工作都是在绑定端完成的。而在方案3中，我们需要修改每个数据库包，增加从AST解析到特定DB引擎并执行查询的方法。

反馈：

> 我更喜欢方案1，因为简单和可维护。方案3的开销太大。在您看来，方案2比方案1有什么好处？